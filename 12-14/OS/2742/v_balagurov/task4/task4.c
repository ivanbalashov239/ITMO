#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>


#define V 7 //Количество вершин графа
#define E 11 //количество рёбер графа

int graph[E][2] = {//Сам граф описанный, как таблица рёбер. Вершины пронумерованны слава направо от 0 до 1.
    {0, 1}, // a
    {0, 4}, // b
    {0, 5}, // c
    {1, 2}, // d
    {2, 3}, // e
    {2, 4}, // f
    {1, 3}, // g
    {3, 4}, // h
    {4, 5}, // i
    {5, 6}, // j
    {5, 6}  // k
};

void *thread_function(void *args)//Треды должны иметь некоторую функцию для исполнения, у всех будет примерно одна функция, в качестве параметра будем передавать номер треда. 
{    
    int i= (int ) args; //Кастнем параметр до int
    printf("Start thread %c\n", (char) i + 97);//Напишем, что тред начался
    sleep((graph[i][1] - graph[i][0])*2); //Подождём некоторое время
    printf("Stop thread %c\n", (char) i + 97);//Напишем, что тред завершился
    pthread_exit(NULL);//И таки завершим его
}

pthread_t threads[E];//Здесь будем хранить указатели на потоки
int v, i;


int main()
{
    for (v = 0; v < V; v++)//Как и в прошлой задаче пройдёмся по всем вершинам
    {
        for (i = 0; i < E; i++)//Для каждой вершины пройдёмся по всем рёбрам
            if (graph[i][1] == v)//И если тред должен закончится в данной вершине
            {
                pthread_join(threads[i], NULL);//То подождём его завершения
                printf("Join thread %c\n", (char) (i + 97));//И напишем, что мы его дождались
            }

        for (i = 0; i < E; i++)//После завершения всех потоков, будем их создавать
            if (graph[i][0] == v)//Если поток начинается в этой вершине, то 
            {
               pthread_create(&threads[i], NULL, thread_function,(void *) i);//Создадим его. Информацию о нём запишем в i ячеёку массива threads, атрибутов дополнительных у потока задавать не будем, для исполнения дадим описанную функцию, в которую передадим номер потока как параметр.
            }
    }
    return 0;
}
